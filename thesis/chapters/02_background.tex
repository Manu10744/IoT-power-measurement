\chapter{Background}\label{chapter:background}

This section aims on providing a general overview of the various tools that were used in this work. In particular, the chosen FaaS platform as well as the employed edge devices needed to construct the experimental cluster will be introduced.

\section{Docker}
\textit{Docker} is an Open-Source containerization platform developed by Docker Inc. which enables software developers to bundle an application together with any associated configuration files and other dependencies, which are required to be available at runtime in order to appropriately operate the software, into Docker images. In the context of containerization, images are standalone, executable software packages containing an isolated filesystem that act as an immutable blueprint for so-called containers, which are created once the respective image is executed. Containers are seperate, isolated processes that run on the host system and can be seen as the direct counterpart of Virtual Machines (VMs) due to the fact that they differ substantially in their characteristics and the way they function. For instance, containers are more lightweight and efficient because they utilize the kernel of the host's operating system (OS) instead of booting their own dedicated operating system, which results in a significant reduction of overhead and startup time. Furthermore, containers are highly portable because they only have to be created once in order to be deployed to any platform or environment as they are abstracted away from the OS of the host they run on. For example, Docker can be installed on Windows, Linux and macOS which makes it possible to deploy a containerized application to any of today's most common operating systems. Additionally, containerization completely eliminates the common problematic situation known from traditional software development where the software in question works in a certain environment, but falls into a faulty state when deployed to a different environment, due to the encapsulation of the application. Consequently, this accelerates productivity as it allows for a reproducible environment due to the fact that a container always behaves in the same way and is independent of the target platform and its surrounding. Lastly, Docker images can easily be shared with other developers by publishing it to an image registry such as Docker's \textit{DockerHub}, which is the world's largest repository service. 

The main component of Docker is the Docker Engine, which is a container runtime that acts as a client-server application and provides the following core features:

\begin{enumerate}
    \item \textit{Docker Daemon}: The Docker Daemon \textit{dockerd} is a persistent process that can be seen as the control plane of Docker. It is responsible for managing images, containers and other docker-related resources.
    \item \textit{Docker Engine API}: The Docker Engine offers a public RESTful API, which specifies interfaces that other programs can use in order to instruct the Docker daemon. These APIs can be accessed by any HTTP client.
    \item \textit{Command Line Interface (CLI)}: The Docker CLI named \textit{docker} acts as a client program that uses the provided APIs in order to communicate with the Docker daemon and can thus be used in order to build images, create or delete containers, pull an image from or push an image to a registry and more~\parencite{docker-engine}.
\end{enumerate}

Even though much of today's software is primarily designed to run on computers that are based on the x86-64 architecture, the situation of having to support different types of system architectures like ARM32v7 or its 64-bit based successor called ARM64v8 is not uncommon, especially in the case of IoT applications which are usually operated across a wide range of heterogeneous devices. To this end, Docker offers the possibility to execute multi-architecture builds for Docker images, which enables application developers to generate and publish multiple versions of a specific image at once, while each one is dedicated to a specific system architecture. Consequently, after uploading the produced images to an image registry, the containerized application can be deployed effortlessly to the intended devices.


\section{Kubernetes}
\textit{Kubernetes} is a famous Open-Source container orchestration tool first introduced by Google, which is designed to automate the deployment, load balancing, scaling and management of containerized applications. Containers run inside a so-called \textit{Pod} which is the smallest deployable unit provided by Kubernetes. Since it is a cluster-based software, it is typically used in a multi-node production environment in which each node performs the task of either the Master or Worker. While the former acts as the cluster's decision maker by hosting the master components of a cluster such as the \textit{kube-scheduler}, which is responsible for assigning a target node to newly created pods, or the key-value based backup store \textit{etcd} which incorporates all data of a cluster, the latter maintains the pods which are components of the application workload by communicating with the master nodes by the help of a running agent called \textit{kubelet} in order to take corresponding instructions. Hence, the application containers managed by Kubernetes are eventually deployed to a cluster's worker nodes~\parencite{k8s-components}. As a result, the architecture of Kubernetes guarantees a great extensibility due to the fact that an existing cluster can easily be scaled by adding more worker nodes. Additionally, a cluster can be made highly-available and fault tolerant by extending it accordingly.

Kubernetes supports a wide range of container runtimes such as \textit{containerd} or any implementation of the Kubernetes Container Runtime (CRI) like CRI-O~\parencite{k8s-components}. Even though Docker has recently been removed from the list of supported runtimes, applications that have been containerized using Docker can still be deployed to Kubernetes as long as they don't directly depend on features or settings that are explicitly provided by Docker~\parencite{k8s-docker-drop}.

\section{Cluster Monitoring \& Data Visualization}
\subsection{Prometheus}
\textit{Prometheus} is an Open-Source, cutting-edge monitoring system that enables administrators to effectively supervise a system's infrastructure and associated applications. It is well known for its polling data collection model which regularly scrapes metrics over HTTP from the services being monitored, which are usually referred to as \textit{targets}, using a configurable time interval. Any data collected by a successful scrape is stored in a time-series database, which enables Prometheus to keep track of changes of the individual metrics over time. For the purpose of data selection and performing operations on the data, Prometheus provides an own query language called \textit{PromQL} which defines a wide range of functions that can be utilized in query expressions. Furthermore, it allows to define certain alert rules that are based on the collected data in order to trigger an alert once a specific condition defined in those rules is met. This allows for sending automatic notifications to administrating staff, which can then act appropriately based on what kind of alert has been triggered.

Generally, there is already a comprehensive amount of applications that natively expose metrics in the format expected by Prometheus. For any cases where this does not apply, a so-called data exporter can be employed, which is responsible for fetching data from third-party systems and transforming them into metrics that can be processed by Prometheus. To this end, client libraries that are available for a variety of programming languages can be made use of in order to implement such an exporter for a specific application.

\subsection{Grafana}
\textit{Grafana} is a modern Open-Source data analytics \& visualization platform that offers the possibility to plot data, which can be obtained from a variety of different sources, using interactive, dynamic dashboards that are composed of a set of highly customizable widgets. Prometheus is one of the most commonly used data sources for Grafana, which qualifies it as another powerful component of a modern system monitoring toolchain. Due to the fact that it provides the opportunity to construct an arbitrary amount of dashboards that are highly configurable, users are able to achieve a visualization of their data that satisfies individual requirements.

\section{OpenFaaS}
OpenFaaS is one of the most popular Open-Source FaaS platforms and is suitable for production-ready, large-scale applications due to the fact that it can be deployed to the commonly known industrial-strength container orchestration systems Kubernetes and OpenShift. On the other hand, it offers an alternative designed for less complex and comprehensive projects named \textit{faasd}, which is a lightweight version of OpenFaaS that offers the opportunity to avoid the complexity of Kubernetes~\parencite{openfaas-deployment}. OpenFaaS is very straightforward and easy to use as serverless functions can be written in any programming language - the only requirement is packaging the application as a container image that complies with the format defined by the \textit{Open Container Initiative} (OCI) and publishing it to an image registry~\parencite{openfaas-intro}. Afterwards, the function can be deployed and invoked by the \textit{API Gateway} which can be accessed via its REST API, the provided Command Line Interface named \textit{faas-cli} or the Web UI. Additionally, invocations can also be triggered by a scheduled cron-job or by third-party systems such as message brokers like \textit{Apache Kafka} or \textit{RabbitMQ}. For the latter, OpenFaaS offers so-called connectors that map a certain topic to multiple functions, which allows for triggering an arbitrary amount of functions once a new message of the specific topic was received by the broker~\parencite{openfaas-triggers}. Figure \ref{fig:openfaas-gateway} provides an overview of the overall function invocation procedure and the individual components that are involved.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{./figures/of-workflow.png}
    \caption{Interaction with the OpenFaaS API Gateway~\parencite{openfaas-stack}}
    \label{fig:openfaas-gateway}
\end{figure}